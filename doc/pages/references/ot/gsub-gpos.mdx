import { Layout } from "components/api-doc"
import { R, Method, Fn, Member, Decl, Item, NthBit } from "components/tyfmt"
import { number, boolean, map, set, array, Data, Ot, Tag, Caster, Thunk } from "components/exports"
import { app, optional, tuple, readonly, pi } from "components/tycon"
export default Layout

# Gsub and Gpos

## Common Structure (Namespace <Decl s={Ot.GsubGpos}/>)

### Type <Decl s={Ot.GsubGpos.Table} />

#### Properties

* <Member s={Ot.GsubGpos.Table.scripts} type={map(Tag, Ot.GsubGpos.Script)}/>
* <Member s={Ot.GsubGpos.Table.features} type={array(Ot.GsubGpos.Feature)}/>
* <Member s={Ot.GsubGpos.Table.lookups} type={array(Ot.GsubGpos.Lookup)}/>
* <Member s={Ot.GsubGpos.Table.featureVariations} type={Data.Maybe(array(Ot.GsubGpos.FeatureVariation))}/>

### Datatype <Decl s={Ot.GsubGpos.Script}/>

Aliased as <Decl s={Ot.Gsub.Script}/>, <Decl s={Ot.Gpos.Script}/>.

#### Members

* <Member s={Ot.GsubGpos.Script.defaultLanguage} type={Data.Maybe(Ot.GsubGpos.Language)}/>
* <Member s={Ot.GsubGpos.Script.languages} type={map(Tag,Ot.GsubGpos.Language)}/>

### Datatype <Decl s={Ot.GsubGpos.Language}/>

Aliased as <Decl s={Ot.Gsub.Language}/>, <Decl s={Ot.Gpos.Language}/>.

#### Members

* <Member s={Ot.GsubGpos.Language.requiredFeature} type={Data.Maybe(Ot.GsubGpos.Feature)}/>
* <Member s={Ot.GsubGpos.Language.features} type={array(Ot.GsubGpos.Feature)}/>

### Datatype <Decl s={Ot.GsubGpos.Feature}/>

Aliased as <Decl s={Ot.Gsub.Feature}/>, <Decl s={Ot.Gpos.Feature}/>.

#### Members

* <Member s={Ot.GsubGpos.Feature.tag} type={Tag}/>
* <Member s={Ot.GsubGpos.Feature.lookups} type={array(Ot.GsubGpos.Lookup)}/>
* <Member s={Ot.GsubGpos.Feature.params} type={optional(Data.Maybe(Caster.Sigma))}/>

### Datatype <Decl s={Ot.GsubGpos.AxisRangeCondition}/>

Aliased as <Decl s={Ot.Gsub.AxisRangeCondition}/>, <Decl s={Ot.Gpos.AxisRangeCondition}/>.

#### Members

* <Member s={Ot.GsubGpos.AxisRangeCondition.axis} type={Ot.Var.Axis}/>
* <Member s={Ot.GsubGpos.AxisRangeCondition.min} type={number}/>
* <Member s={Ot.GsubGpos.AxisRangeCondition.max} type={number}/>

### Type Alias <Decl s={Ot.GsubGpos.FeatureVariationCondition}/> = <R s={Ot.GsubGpos.AxisRangeCondition}/>

Aliased as <Decl s={Ot.Gsub.FeatureVariationCondition}/>, <Decl s={Ot.Gpos.FeatureVariationCondition}/>.

### Datatype <Decl s={Ot.GsubGpos.FeatureVariation}/>

Aliased as <Decl s={Ot.Gsub.FeatureVariation}/>, <Decl s={Ot.Gpos.FeatureVariation}/>.

#### Members

* <Member s={Ot.GsubGpos.FeatureVariation.conditions} type={array(Ot.GsubGpos.FeatureVariationCondition)}/>
* <Member s={Ot.GsubGpos.FeatureVariation.substitutions} type={map(Ot.GsubGpos.Feature, Ot.GsubGpos.Feature)}/>

## Lookups and Lookup Algebra

### Interface <Decl s={Ot.GsubGpos.Lookup} />

Aliased as <Decl s={Ot.Gsub.Lookup} />, <Decl s={Ot.Gpos.Lookup} />

#### Inherits

* <R s={Ot.GsubGpos.LookupProp} />

#### Methods

* <Method s={Ot.GsubGpos.Lookup.acceptLookupAlgebra("E")} args={{alg:Ot.GsubGpos.LookupAlg("E")}} returns="E"/>

### Interface <Decl s={Ot.GsubGpos.LookupProp}/>

Aliased as <Decl s={Ot.Gsub.LookupProp}/>, <Decl s={Ot.Gpos.LookupProp}/>.

#### Properties

* <Member s={Ot.GsubGpos.LookupProp.rightRoLeft} type={boolean}/>
* <Member s={Ot.GsubGpos.LookupProp.ignoreGlyphs} type={Data.Maybe(set(Ot.Glyph))}/>

### Interface <Decl s={Ot.GsubGpos.LookupAlg("E")}/>

Aliased as <Decl s={Ot.Gsub.LookupAlg("E")}/>, <Decl s={Ot.Gpos.LookupAlg("E")}/>.

#### Methods

* <Method s={Ot.GsubGpos.LookupAlg.gsubSingle} args={{thProps:Thunk(Ot.Gsub.SingleProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubMulti} args={{thProps:Thunk(Ot.Gsub.MultipleAlternateProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubAlternate} args={{thProps:Thunk(Ot.Gsub.MultipleAlternateProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubLigature} args={{thProps:Thunk(Ot.Gsub.LigatureProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubChaining} args={{thProps:Thunk(Ot.GsubGsub.ChainingProp("E"))}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubReverse} args={{thProps:Thunk(Ot.Gsub.ReverseSubProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposSingle} args={{thProps:Thunk(Ot.Gpos.SingleProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposPair} args={{thProps:Thunk(Ot.Gpos.PairProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposCursive} args={{thProps:Thunk(Ot.Gpos.CursiveProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposMarkToBase} args={{thProps:Thunk(Ot.Gpos.MarkToBaseProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposMarkToLigature} args={{thProps:Thunk(Ot.Gpos.MarkToLigatureProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposMarkToMark} args={{thProps:Thunk(Ot.Gpos.MarkToMarkProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposChaining} args={{thProps:Thunk(Ot.GsubGpos.ChainingProp("E"))}} returns="E"/>
* <Method optional s={Ot.GsubGpos.LookupAlg.crossReference} args={{source:"object",thValue:Thunk("E")}} returns="E"/>




## Namespace <Decl s={Ot.Gsub}/>

### Constant <Decl s={Ot.Gsub.Tag}/> = `"GSUB"`

### Class <Decl s={Ot.Gsub.Table} />

#### Implements

* <R s={Ot.GsubGpos.Table}/>

#### Constructor

* <Method ctor s={Ot.Gsub.Table.constructor}/>

### Class <Decl s={Ot.Gsub.Single}/>

#### Implements

* <R s={Ot.Gsub.SingleProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gsub.Single.constructor}/>

### Datatype <Decl s={Ot.Gsub.SingleProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.SingleProp.mapping} type={map(Ot.Glyph, Ot.Glyph)}/>

### Class <Decl s={Ot.Gsub.Multiple}/>

#### Implements

* <R s={Ot.Gsub.MultipleAlternateProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gsub.Multiple.constructor}/>

### Class <Decl s={Ot.Gsub.Alternate}/>

#### Implements

* <R s={Ot.Gsub.MultipleAlternateProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gsub.Alternate.constructor}/>

### Datatype <Decl s={Ot.Gsub.MultipleAlternateProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.MultipleAlternateProp.mapping} type={map(Ot.Glyph, readonly(array(Ot.Glyph)))}/>

### Class <Decl s={Ot.Gsub.Ligature}/>

#### Implements

* <R s={Ot.Gsub.LigatureProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gsub.Ligature.constructor}/>

### Datatype <Decl s={Ot.Gsub.LigatureProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.LigatureProp.mapping} type={array(Ot.Gsub.LigatureEntry)}/>

### Datatype <Decl s={Ot.Gsub.LigatureEntry}/>

#### Properties

* <Member readonly s={Ot.Gsub.LigatureEntry.from} type={readonly(array(Ot.Glyph))}/>
* <Member readonly s={Ot.Gsub.LigatureEntry.to} type={Ot.Glyph}/>

### Class <Decl s={Ot.Gsub.Chaining}/>

#### Implements

* <R s={Ot.GsubGpos.ChainingProp(Ot.GsubGpos.Lookup)}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gsub.Chaining.constructor}/>

### Class <Decl s={Ot.Gsub.ReverseSub}/>

#### Implements

* <R s={Ot.Gsub.ReverseSubProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gsub.ReverseSub.constructor}/>

### Datatype <Decl s={Ot.Gsub.ReverseSubProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.ReverseSubProp.rules} type={array(Ot.Gsub.ReverseRule)}/>

### Datatype <Decl s={Ot.Gsub.ReverseRule}/>

#### Properties

* <Member s={Ot.Gsub.ReverseRule.match} type={set(Ot.Glyph)}/>
* <Member s={Ot.Gsub.ReverseRule.doSubAt} type={number}/>
* <Member s={Ot.Gsub.ReverseRule.replacement} type={map(Ot.Glyph,Ot.Glyph)}/>



## Namespace <Decl s={Ot.Gpos}/>

### Constant <Decl s={Ot.Gpos.Tag}/> = `"GPOS"`

### Class <Decl s={Ot.Gpos.Table} />

#### Implements

* <R s={Ot.GsubGpos.Table}/>

#### Constructor

* <Method ctor s={Ot.Gpos.Table.constructor}/>

### Class <Decl s={Ot.Gpos.Single}/>

#### Implements

* <R s={Ot.Gpos.SingleProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gpos.Single.constructor}/>

### Datatype <Decl s={Ot.Gpos.SingleProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.SingleProp.adjustments} type={map(Ot.Glyph, Ot.Gpos.Adjustment)}/>

### Class <Decl s={Ot.Gpos.Pair}/>

#### Implements

* <R s={Ot.Gpos.PairProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gpos.Pair.constructor}/>

### Datatype <Decl s={Ot.Gpos.PairProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.PairProp.adjustments} type={Ot.DicingStore(Ot.Glyph,Ot.Glyph,Ot.Gpos.AdjustmentPair)}/>

### Class <Decl s={Ot.Gpos.Cursive}/>

#### Implements

* <R s={Ot.Gpos.CursiveProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gpos.Cursive.constructor}/>

### Datatype <Decl s={Ot.Gpos.CursiveProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.CursiveProp.attachments} type={map(Ot.Glyph,Ot.Gpos.CursiveAnchorPair)}/>

### Class <Decl s={Ot.Gpos.MarkToBase}/>

#### Implements

* <R s={Ot.Gpos.MarkToBaseProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gpos.MarkToBase.constructor}/>

### Datatype <Decl s={Ot.Gpos.MarkToBaseProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToBaseProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToBaseProp.bases} type={map(Ot.Glyph,Ot.Gpos.BaseRecord)}/>

### Class <Decl s={Ot.Gpos.MarkToLigature}/>

#### Implements

* <R s={Ot.Gpos.MarkToLigatureProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gpos.MarkToLigature.constructor}/>

### Datatype <Decl s={Ot.Gpos.MarkToLigatureProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToLigatureProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToLigatureProp.bases} type={map(Ot.Glyph,Ot.Gpos.LigatureBaseRecord)}/>

### Class <Decl s={Ot.Gpos.MarkToMark}/>

#### Implements

* <R s={Ot.Gpos.MarkToMarkProp}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gpos.MarkToMark.constructor}/>

### Datatype <Decl s={Ot.Gpos.MarkToMarkProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToMarkProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToMarkProp.baseMarks} type={map(Ot.Glyph,Ot.Gpos.BaseRecord)}/>

### Class <Decl s={Ot.Gpos.Chaining}/>

#### Implements

* <R s={Ot.GsubGpos.ChainingProp(Ot.GsubGpos.Lookup)}/>
* <R s={Ot.GsubGpos.Lookup}/>

#### Constructor

* <Method ctor s={Ot.Gpos.Chaining.constructor}/>



## Shared Chaining Lookup

### Datatype <Decl s={Ot.GsubGpos.ChainingProp("E")}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

Aliased as <Decl s={Ot.Gsub.ChainingProp("E")}/>, <Decl s={Ot.Gpos.ChainingProp("E")}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingProp.rules} type={array(Ot.GsubGpos.ChainingRule("E"))}/>

### Datatype <Decl s={Ot.GsubGpos.ChainingRule("E")}/>

Aliased as <Decl s={Ot.Gsub.ChainingRule("E")}/>, <Decl s={Ot.Gpos.ChainingRule("E")}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingRule.match} type={array(set(Ot.Glyph))}/>
* <Member s={Ot.GsubGpos.ChainingRule.inputBegins} type={number}/>
* <Member s={Ot.GsubGpos.ChainingRule.inputEnds} type={number}/>
* <Member s={Ot.GsubGpos.ChainingRule.applications} type={array(Ot.GsubGpos.ChainingApplication("E"))}/>

### Datatype <Decl s={Ot.GsubGpos.ChainingApplication("E")}/>

Aliased as <Decl s={Ot.Gsub.ChainingApplication("E")}/>, <Decl s={Ot.Gpos.ChainingApplication("E")}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingApplication.at} type={number}/>
* <Member s={Ot.GsubGpos.ChainingApplication.apply} type="E"/>






## Shared GSUB + GPOS Support Types

### Type <Decl s={Ot.GsubGpos.Coverage}/> = <R s={set(Ot.Glyph)}/>

Also aliased as <Decl s={Ot.Gsub.Coverage}/>, <Decl s={Ot.Gpos.Coverage}/>

### Type <Decl s={Ot.GsubGpos.ClassDef}/> = <R s={map(Ot.Glyph,number)}/>

Also aliased as <Decl s={Ot.Gsub.ClassDef}/>, <Decl s={Ot.Gpos.ClassDef}/>

### Datatype <Decl s={Ot.Gpos.Adjustment}/>

#### Properties
* <Member readonly s={Ot.Gpos.Adjustment.dX} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dXDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dY} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dYDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dWidth} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dWidthDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dHeight} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dHeightDevice} type={optional(Data.Maybe(readonly(array(number))))}/>

### Datatype <Decl s={Ot.Gpos.AdjustmentPair}/> = <R s={tuple(Ot.Gpos.Adjustment,Ot.Gpos.Adjustment)}/>

### Datatype <Decl s={Ot.Gpos.Anchor}/>

#### Properties
* <Member readonly s={Ot.Gpos.Anchor.x} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Anchor.xDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Anchor.y} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Anchor.yDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gdef.Anchor.pointAttachment} type={optional(Data.Maybe(Ot.Gdef.PointIDRef))}/>

### Datatype <Decl s={Ot.Gpos.CursiveAnchorPair}/>

#### Properties
* <Member readonly s={Ot.Gpos.CursiveAnchorPair.entry} type={Data.Maybe(Ot.Gpos.Anchor)}/>
* <Member readonly s={Ot.Gpos.CursiveAnchorPair.exit} type={Data.Maybe(Ot.Gpos.Anchor)}/>

### Datatype <Decl s={Ot.Gpos.MarkRecord}/>

#### Properties
* <Member s={Ot.Gpos.MarkRecord.markAnchors} type={array(Data.Maybe(Ot.Gpos.Anchor))}/>

### Datatype <Decl s={Ot.Gpos.BaseRecord}/>

#### Properties
* <Member s={Ot.Gpos.BaseRecord.baseAnchors} type={array(Data.Maybe(Ot.Gpos.Anchor))}/>

### Datatype <Decl s={Ot.Gpos.LigatureBaseRecord}/>

#### Properties
* <Member s={Ot.Gpos.LigatureBaseRecord.baseAnchors} type={array(array(Data.Maybe(Ot.Gpos.Anchor)))}/>





## Feature Parameters (<Decl s={Ot.GsubGpos.FeatureParams}/>)

This namespace is aliased as <Decl s={Ot.Gsub.FeatureParams}/> and <Decl s={Ot.Gpos.FeatureParams}/>.

### Datatype <Decl s={Ot.GsubGpos.FeatureParams.StylisticSet}/>

#### Type ID

* <Decl s={Ot.GsubGpos.FeatureParams.TID_StylisticSet}/>

#### Members

* <Member readonly s={Ot.GsubGpos.FeatureParams.StylisticSet.uiNameID} type={number}/>


## Dicing Store

### Opaque Type <Decl s={Ot.DicingStore("X","Y","D")}/>

#### Methods

* <Method s={Ot.DicingStore.get} args={{x:"X",y:"Y"}} returns={Data.Maybe("D")}/>
* <Method s={Ot.DicingStore.getByClass} args={{cx:number,cy:number}} returns={Data.Maybe("D")}/>
* <Method s={Ot.DicingStore.getXClassDef} returns={array(array("X"))}/>
* <Method s={Ot.DicingStore.getYClassDef} returns={array(array("Y"))}/>
* <Method s={Ot.DicingStore.entries} returns={app("IterableIterator",tuple("X","Y",Data.Maybe("D")))}/>
* <Method s={Ot.DicingStore.set} args={{x:set("X"),y:set("Y"),value:"D"}} returns="void"/>
* <Method s={Ot.DicingStore.setIfAbsent} args={{x:set("X"),y:set("Y"),value:"D"}} returns="void"/>
* <Method s={Ot.DicingStore.update} args={{x:set("X"),y:set("Y"),fn:pi({original:Data.Maybe("D")},"D")}} returns="void"/>