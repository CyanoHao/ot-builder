import { Layout } from "components/api-doc"
import { R, Method, Fn, Member, Decl, Item, NthBit } from "components/tyfmt"
import { number, boolean, map, set, array, Data, Ot, Tag, Caster, Thunk } from "components/exports"
import { app, optional, tuple, readonly, pi } from "components/tycon"
export default Layout

# Gsub and Gpos

## Common Structure (Namespace <Decl s={Ot.GsubGpos}/>)

### Datatype <Decl s={Ot.GsubGpos.TableT("L")}/>

#### Properties

* <Member s={Ot.GsubGpos.TableT.scripts} type={map(Tag, Ot.GsubGpos.ScriptT("L"))}/>
* <Member s={Ot.GsubGpos.TableT.features} type={array(Ot.GsubGpos.FeatureT("L"))}/>
* <Member s={Ot.GsubGpos.TableT.lookups} type={array("L")}/>
* <Member s={Ot.GsubGpos.TableT.featureVariations} type={Data.Maybe(array(Ot.GsubGpos.FeatureVariationT("L")))}/>

### Datatype <Decl s={Ot.GsubGpos.ScriptT("L")}/>

#### Members

* <Member s={Ot.GsubGpos.ScriptT.defaultLanguage} type={Data.Maybe(Ot.GsubGpos.LanguageT("L"))}/>
* <Member s={Ot.GsubGpos.ScriptT.languages} type={map(Tag,Ot.GsubGpos.LanguageT("L"))}/>

### Datatype <Decl s={Ot.GsubGpos.LanguageT("L")}/>

#### Members

* <Member s={Ot.GsubGpos.LanguageT.requiredFeature} type={Data.Maybe(Ot.GsubGpos.FeatureT("L"))}/>
* <Member s={Ot.GsubGpos.LanguageT.features} type={array(Ot.GsubGpos.FeatureT("L"))}/>

### Datatype <Decl s={Ot.GsubGpos.FeatureT("L")}/>

#### Members

* <Member s={Ot.GsubGpos.FeatureT.tag} type={Tag}/>
* <Member s={Ot.GsubGpos.FeatureT.lookups} type={array("L")}/>
* <Member s={Ot.GsubGpos.FeatureT.params} type={optional(Data.Maybe(Caster.Sigma))}/>

### Datatype <Decl s={Ot.GsubGpos.AxisRangeCondition}/>

Aliased as <Decl s={Ot.Gsub.AxisRangeCondition}/>, <Decl s={Ot.Gpos.AxisRangeCondition}/>.

#### Members

* <Member s={Ot.GsubGpos.AxisRangeCondition.axis} type={Ot.Var.Axis}/>
* <Member s={Ot.GsubGpos.AxisRangeCondition.min} type={number}/>
* <Member s={Ot.GsubGpos.AxisRangeCondition.max} type={number}/>

### Type Alias <Decl s={Ot.GsubGpos.FeatureVariationCondition}/> = <R s={Ot.GsubGpos.AxisRangeCondition}/>

Aliased as <Decl s={Ot.Gsub.FeatureVariationCondition}/>, <Decl s={Ot.Gpos.FeatureVariationCondition}/>.

### Datatype <Decl s={Ot.GsubGpos.FeatureVariationT("L")}/>

#### Members

* <Member s={Ot.GsubGpos.FeatureVariationT.conditions} type={array(Ot.GsubGpos.FeatureVariationCondition)}/>
* <Member s={Ot.GsubGpos.FeatureVariationT.substitutions} type={map(Ot.GsubGpos.FeatureT("L"), Ot.GsubGpos.FeatureT("L"))}/>

### Interface <Decl s={Ot.GsubGpos.LookupProp}/>

Aliased as <Decl s={Ot.Gsub.LookupProp}/>, <Decl s={Ot.Gpos.LookupProp}/>.

#### Properties

* <Member s={Ot.GsubGpos.LookupProp.rightRoLeft} type={boolean}/>
* <Member s={Ot.GsubGpos.LookupProp.ignoreGlyphs} type={Data.Maybe(set(Ot.Glyph))}/>


## Namespace <Decl s={Ot.Gsub}/>

### Constant <Decl s={Ot.Gsub.Tag}/> = `"GSUB"`

### Type <Decl s={Ot.Gsub.Table} />

#### Inherits

* <R s={Ot.GsubGpos.TableT(Ot.Gsub.Lookup)}/>

#### Factory Methods

* <Method static long s={Ot.Gsub.Table.create} args={{
    scripts:optional(map(Tag,Ot.Gsub.Script)),
    features:optional(array(Ot.Gsub.Feature)),
    lookups:optional(array(Ot.Gsub.Lookup)),
    featureVariations:optional(Data.Maybe(Ot.Gsub.FeatureVariation)),
    }}/>

### Datatype <Decl s={Ot.Gsub.Script}/>

Defined as <R s={Ot.GsubGpos.ScriptT(Ot.Gsub.Lookup)}/>

### Datatype <Decl s={Ot.Gsub.Language}/>

Defined as <R s={Ot.GsubGpos.LanguageT(Ot.Gsub.Lookup)}/>

### Datatype <Decl s={Ot.Gsub.Feature}/>

Defined as <R s={Ot.GsubGpos.FeatureT(Ot.Gsub.Lookup)}/>

### Datatype <Decl s={Ot.Gsub.FeatureVariation}/>

Defined as <R s={Ot.GsubGpos.FeatureVariationT(Ot.Gsub.Lookup)}/>

### Interface <Decl s={Ot.Gsub.Lookup} />

#### Inherits

* <R s={Ot.GsubGpos.LookupProp} />

#### Methods

* <Method s={Ot.Gsub.Lookup.apply("E")} args={{alg:Ot.Gsub.LookupAlg("E")}} returns="E"/>

### Interface <Decl s={Ot.Gsub.LookupAlg("E")}/>

#### Methods

* <Method s={Ot.GsubGpos.LookupAlg.gsubSingle} args={{thProps:Thunk(Ot.Gsub.SingleProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubMulti} args={{thProps:Thunk(Ot.Gsub.MultipleAlternateProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubAlternate} args={{thProps:Thunk(Ot.Gsub.MultipleAlternateProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubLigature} args={{thProps:Thunk(Ot.Gsub.LigatureProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubChaining} args={{thProps:Thunk(Ot.GsubGpos.ChainingProp("E"))}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gsubReverse} args={{thProps:Thunk(Ot.Gsub.ReverseSubProp)}} returns="E"/>
* <Method optional s={Ot.GsubGpos.LookupAlg.crossReference} args={{source:"object",thValue:Thunk("E")}} returns="E"/>


### Type <Decl s={Ot.Gsub.Single}/>

#### Inherits

* <R s={Ot.Gsub.SingleProp}/>
* <R s={Ot.Gsub.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Single.create}/>

### Datatype <Decl s={Ot.Gsub.SingleProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.SingleProp.mapping} type={map(Ot.Glyph, Ot.Glyph)}/>

### Type <Decl s={Ot.Gsub.Multiple}/>

<R s={Ot.Gsub.Multiple}/> is structurally identical to <R s={Ot.Gsub.Alternate}/>. However their <code>apply</code> implementation responds to different methods in the <R s={Ot.GsubGpos.LookupAlg}/>: <R s={Ot.Gsub.Multiple}/> responds to <code>gsubMulti</code>, while <R s={Ot.Gsub.Alternate}/> responds to <code>gsubAlternate</code>.

#### Inherits

* <R s={Ot.Gsub.MultipleAlternateProp}/>
* <R s={Ot.Gsub.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Multiple.create}/>

### Type <Decl s={Ot.Gsub.Alternate}/>

<R s={Ot.Gsub.Alternate}/> is structurally identical to <R s={Ot.Gsub.Multiple}/>. However their <code>apply</code> implementation responds to different methods in the <R s={Ot.GsubGpos.LookupAlg}/>: <R s={Ot.Gsub.Multiple}/> responds to <code>gsubMulti</code>, while <R s={Ot.Gsub.Alternate}/> responds to <code>gsubAlternate</code>.

#### Inherits

* <R s={Ot.Gsub.MultipleAlternateProp}/>
* <R s={Ot.Gsub.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Alternate.create}/>

### Datatype <Decl s={Ot.Gsub.MultipleAlternateProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.MultipleAlternateProp.mapping} type={map(Ot.Glyph, readonly(array(Ot.Glyph)))}/>

### Type <Decl s={Ot.Gsub.Ligature}/>

#### Inherits

* <R s={Ot.Gsub.LigatureProp}/>
* <R s={Ot.Gsub.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Ligature.create}/>

### Datatype <Decl s={Ot.Gsub.LigatureProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.LigatureProp.mapping} type={array(Ot.Gsub.LigatureEntry)}/>

### Datatype <Decl s={Ot.Gsub.LigatureEntry}/>

#### Properties

* <Member readonly s={Ot.Gsub.LigatureEntry.from} type={readonly(array(Ot.Glyph))}/>
* <Member readonly s={Ot.Gsub.LigatureEntry.to} type={Ot.Glyph}/>

### Type <Decl s={Ot.Gsub.Chaining}/>

#### Inherits

* <R s={Ot.GsubGpos.ChainingProp(Ot.Gsub.Lookup)}/>
* <R s={Ot.Gsub.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gsub.Chaining.create}/>

### Type <Decl s={Ot.Gsub.ReverseSub}/>

#### Inherits

* <R s={Ot.Gsub.ReverseSubProp}/>
* <R s={Ot.Gsub.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gsub.ReverseSub.create}/>

### Datatype <Decl s={Ot.Gsub.ReverseSubProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gsub.ReverseSubProp.rules} type={array(Ot.Gsub.ReverseRule)}/>

### Datatype <Decl s={Ot.Gsub.ReverseRule}/>

#### Properties

* <Member s={Ot.Gsub.ReverseRule.match} type={set(Ot.Glyph)}/>
* <Member s={Ot.Gsub.ReverseRule.doSubAt} type={number}/>
* <Member s={Ot.Gsub.ReverseRule.replacement} type={map(Ot.Glyph,Ot.Glyph)}/>





## Namespace <Decl s={Ot.Gpos}/>

### Constant <Decl s={Ot.Gpos.Tag}/> = `"GPOS"`

### Type <Decl s={Ot.Gpos.Table} />

#### Inherits

* <R s={Ot.GsubGpos.TableT(Ot.Gpos.Lookup)}/>

#### Factory Methods

* <Method static long s={Ot.Gpos.Table.create} args={{
    scripts:optional(map(Tag,Ot.Gpos.Script)),
    features:optional(array(Ot.Gpos.Feature)),
    lookups:optional(array(Ot.Gpos.Lookup)),
    featureVariations:optional(Data.Maybe(Ot.Gpos.FeatureVariation)),
    }}/>

### Datatype <Decl s={Ot.Gpos.Script}/>

Defined as <R s={Ot.GsubGpos.ScriptT(Ot.Gpos.Lookup)}/>

### Datatype <Decl s={Ot.Gpos.Language}/>

Defined as <R s={Ot.GsubGpos.LanguageT(Ot.Gpos.Lookup)}/>

### Datatype <Decl s={Ot.Gpos.Feature}/>

Defined as <R s={Ot.GsubGpos.FeatureT(Ot.Gpos.Lookup)}/>

### Datatype <Decl s={Ot.Gpos.FeatureVariation}/>

Defined as <R s={Ot.GsubGpos.FeatureVariationT(Ot.Gpos.Lookup)}/>

### Interface <Decl s={Ot.Gpos.Lookup} />

#### Inherits

* <R s={Ot.GsubGpos.LookupProp} />

#### Methods

* <Method s={Ot.Gpos.Lookup.apply("E")} args={{alg:Ot.Gpos.LookupAlg("E")}} returns="E"/>

### Interface <Decl s={Ot.Gpos.LookupAlg("E")}/>

#### Methods

* <Method s={Ot.GsubGpos.LookupAlg.gposSingle} args={{thProps:Thunk(Ot.Gpos.SingleProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposPair} args={{thProps:Thunk(Ot.Gpos.PairProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposCursive} args={{thProps:Thunk(Ot.Gpos.CursiveProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposMarkToBase} args={{thProps:Thunk(Ot.Gpos.MarkToBaseProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposMarkToLigature} args={{thProps:Thunk(Ot.Gpos.MarkToLigatureProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposMarkToMark} args={{thProps:Thunk(Ot.Gpos.MarkToMarkProp)}} returns="E"/>
* <Method s={Ot.GsubGpos.LookupAlg.gposChaining} args={{thProps:Thunk(Ot.GsubGpos.ChainingProp("E"))}} returns="E"/>
* <Method optional s={Ot.GsubGpos.LookupAlg.crossReference} args={{source:"object",thValue:Thunk("E")}} returns="E"/>


### Type <Decl s={Ot.Gpos.Single}/>

#### Inherits

* <R s={Ot.Gpos.SingleProp}/>
* <R s={Ot.Gpos.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gpos.Single.create}/>

### Datatype <Decl s={Ot.Gpos.SingleProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.SingleProp.adjustments} type={map(Ot.Glyph, Ot.Gpos.Adjustment)}/>

### Type <Decl s={Ot.Gpos.Pair}/>

#### Inherits

* <R s={Ot.Gpos.PairProp}/>
* <R s={Ot.Gpos.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gpos.Pair.create}/>

### Datatype <Decl s={Ot.Gpos.PairProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.PairProp.adjustments} type={Ot.DicingStore(Ot.Glyph,Ot.Glyph,Ot.Gpos.AdjustmentPair)}/>

### Type <Decl s={Ot.Gpos.Cursive}/>

#### Inherits

* <R s={Ot.Gpos.CursiveProp}/>
* <R s={Ot.Gpos.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gpos.Cursive.create}/>

### Datatype <Decl s={Ot.Gpos.CursiveProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.CursiveProp.attachments} type={map(Ot.Glyph,Ot.Gpos.CursiveAnchorPair)}/>

### Type <Decl s={Ot.Gpos.MarkToBase}/>

#### Inherits

* <R s={Ot.Gpos.MarkToBaseProp}/>
* <R s={Ot.Gpos.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gpos.MarkToBase.create}/>

### Datatype <Decl s={Ot.Gpos.MarkToBaseProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToBaseProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToBaseProp.bases} type={map(Ot.Glyph,Ot.Gpos.BaseRecord)}/>

### Type <Decl s={Ot.Gpos.MarkToLigature}/>

#### Inherits

* <R s={Ot.Gpos.MarkToLigatureProp}/>
* <R s={Ot.Gpos.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gpos.MarkToLigature.create}/>

### Datatype <Decl s={Ot.Gpos.MarkToLigatureProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToLigatureProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToLigatureProp.bases} type={map(Ot.Glyph,Ot.Gpos.LigatureBaseRecord)}/>

### Type <Decl s={Ot.Gpos.MarkToMark}/>

#### Inherits

* <R s={Ot.Gpos.MarkToMarkProp}/>
* <R s={Ot.Gpos.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gpos.MarkToMark.create}/>

### Datatype <Decl s={Ot.Gpos.MarkToMarkProp}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.Gpos.MarkToMarkProp.marks} type={map(Ot.Glyph,Ot.Gpos.MarkRecord)}/>
* <Member s={Ot.Gpos.MarkToMarkProp.baseMarks} type={map(Ot.Glyph,Ot.Gpos.BaseRecord)}/>

### Type <Decl s={Ot.Gpos.Chaining}/>

#### Inherits

* <R s={Ot.GsubGpos.ChainingProp(Ot.Gpos.Lookup)}/>
* <R s={Ot.Gpos.Lookup}/>

#### Factory Methods

* <Method static s={Ot.Gpos.Chaining.create}/>



## Shared Chaining Lookup

### Datatype <Decl s={Ot.GsubGpos.ChainingProp("E")}/>

Aliased as <Decl s={Ot.Gsub.ChainingProp("E")}/>, <Decl s={Ot.Gpos.ChainingProp("E")}/>

#### Inherits

* <R s={Ot.GsubGpos.LookupProp}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingProp.rules} type={array(Ot.GsubGpos.ChainingRule("E"))}/>

### Datatype <Decl s={Ot.GsubGpos.ChainingRule("E")}/>

Aliased as <Decl s={Ot.Gsub.ChainingRule("E")}/>, <Decl s={Ot.Gpos.ChainingRule("E")}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingRule.match} type={array(set(Ot.Glyph))}/>
* <Member s={Ot.GsubGpos.ChainingRule.inputBegins} type={number}/>
* <Member s={Ot.GsubGpos.ChainingRule.inputEnds} type={number}/>
* <Member s={Ot.GsubGpos.ChainingRule.applications} type={array(Ot.GsubGpos.ChainingApplication("E"))}/>

### Datatype <Decl s={Ot.GsubGpos.ChainingApplication("E")}/>

Aliased as <Decl s={Ot.Gsub.ChainingApplication("E")}/>, <Decl s={Ot.Gpos.ChainingApplication("E")}/>

#### Properties

* <Member s={Ot.GsubGpos.ChainingApplication.at} type={number}/>
* <Member s={Ot.GsubGpos.ChainingApplication.apply} type="E"/>






## Shared GSUB + GPOS Support Types

### Type <Decl s={Ot.GsubGpos.Coverage}/> = <R s={set(Ot.Glyph)}/>

Also aliased as <Decl s={Ot.Gsub.Coverage}/>, <Decl s={Ot.Gpos.Coverage}/>

### Type <Decl s={Ot.GsubGpos.ClassDef}/> = <R s={map(Ot.Glyph,number)}/>

Also aliased as <Decl s={Ot.Gsub.ClassDef}/>, <Decl s={Ot.Gpos.ClassDef}/>

### Datatype <Decl s={Ot.Gpos.Adjustment}/>

#### Properties
* <Member readonly s={Ot.Gpos.Adjustment.dX} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dXDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dY} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dYDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dWidth} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dWidthDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Adjustment.dHeight} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Adjustment.dHeightDevice} type={optional(Data.Maybe(readonly(array(number))))}/>

### Datatype <Decl s={Ot.Gpos.AdjustmentPair}/> = <R s={tuple(Ot.Gpos.Adjustment,Ot.Gpos.Adjustment)}/>

### Datatype <Decl s={Ot.Gpos.Anchor}/>

#### Properties
* <Member readonly s={Ot.Gpos.Anchor.x} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Anchor.xDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gpos.Anchor.y} type={Ot.Var}/>
* <Member readonly s={Ot.Gpos.Anchor.yDevice} type={optional(Data.Maybe(readonly(array(number))))}/>
* <Member readonly s={Ot.Gdef.Anchor.pointAttachment} type={optional(Data.Maybe(Ot.Gdef.PointIDRef))}/>

### Datatype <Decl s={Ot.Gpos.CursiveAnchorPair}/>

#### Properties
* <Member readonly s={Ot.Gpos.CursiveAnchorPair.entry} type={Data.Maybe(Ot.Gpos.Anchor)}/>
* <Member readonly s={Ot.Gpos.CursiveAnchorPair.exit} type={Data.Maybe(Ot.Gpos.Anchor)}/>

### Datatype <Decl s={Ot.Gpos.MarkRecord}/>

#### Properties
* <Member s={Ot.Gpos.MarkRecord.markAnchors} type={array(Data.Maybe(Ot.Gpos.Anchor))}/>

### Datatype <Decl s={Ot.Gpos.BaseRecord}/>

#### Properties
* <Member s={Ot.Gpos.BaseRecord.baseAnchors} type={array(Data.Maybe(Ot.Gpos.Anchor))}/>

### Datatype <Decl s={Ot.Gpos.LigatureBaseRecord}/>

#### Properties
* <Member s={Ot.Gpos.LigatureBaseRecord.baseAnchors} type={array(array(Data.Maybe(Ot.Gpos.Anchor)))}/>





## Feature Parameters (<Decl s={Ot.GsubGpos.FeatureParams}/>)

This namespace is aliased as <Decl s={Ot.Gsub.FeatureParams}/> and <Decl s={Ot.Gpos.FeatureParams}/>.

### Datatype <Decl s={Ot.GsubGpos.FeatureParams.StylisticSet}/>

#### Type ID

* <Decl s={Ot.GsubGpos.FeatureParams.TID_StylisticSet}/>

#### Members

* <Member readonly s={Ot.GsubGpos.FeatureParams.StylisticSet.uiNameID} type={number}/>


## Dicing Store

### Opaque Type <Decl s={Ot.DicingStore("X","Y","D")}/>

#### Methods

* <Method s={Ot.DicingStore.get} args={{x:"X",y:"Y"}} returns={Data.Maybe("D")}/>
* <Method s={Ot.DicingStore.getByClass} args={{cx:number,cy:number}} returns={Data.Maybe("D")}/>
* <Method s={Ot.DicingStore.getXClassDef} returns={array(array("X"))}/>
* <Method s={Ot.DicingStore.getYClassDef} returns={array(array("Y"))}/>
* <Method s={Ot.DicingStore.entries} returns={app("IterableIterator",tuple("X","Y",Data.Maybe("D")))}/>
* <Method s={Ot.DicingStore.set} args={{x:set("X"),y:set("Y"),value:"D"}} returns="void"/>
* <Method s={Ot.DicingStore.setIfAbsent} args={{x:set("X"),y:set("Y"),value:"D"}} returns="void"/>
* <Method s={Ot.DicingStore.update} args={{x:set("X"),y:set("Y"),fn:pi({original:Data.Maybe("D")},"D")}} returns="void"/>