import { Layout } from "components/api-doc"
import { R, Method, Fn, Member, Decl, Item } from "components/tyfmt"
import { string, boolean, number, array, set, Ot, Data, Thunk } from "components/exports"
import { optional, all, pi, annot } from "components/tycon"
export default Layout

# <Decl s={Ot.Glyph}/>

The type-namespace duplex <R s={Ot.Glyph}/> defines the datatype, related datatype and operations for OpenType glyphs.

## Glyph Store

A <R s={Ot.Font}/> support any datatypt implemented <R s={Data.OrderStore(Ot.Glyph)}/> to be the glyph store. `ot-builder` provided <R s={Ot.ListGlyphStore} /> as the default glyph store implementation.

### Type <Decl s={Ot.ListGlyphStore} />

An opaque class that implements <R s={Data.OrderStore(Ot.Glyph)}/>. Created by <R s={Ot.ListGlyphStoreFactory}/>.

### Singleton <Decl s={Ot.ListGlyphStoreFactory} />

An opaque factory object that implements <R s={Data.OrderStoreFactoryWithDefault(Ot.Glyph, Ot.ListGlyphStore)}/>.

## Glyph

### Type <Decl s={Ot.Glyph}/>

#### Factory Methods

 * <Fn s={Ot.Glyph.create}/>

    Create a blank <R s={Ot.Glyph}/> with default implementation.

#### Properties

 * <Member s={Ot.Glyph.name} type={Data.Maybe(string)}/>

    The glyph name. Optional.

 * <Member s={Ot.Glyph.geometry} type={Data.Maybe(Ot.Glyph.Geometry)}/>

    The geometry. Optional. When absent, the glyph is considered a space.

 * <Member s={Ot.Glyph.hints} type={Data.Maybe(Ot.Glyph.Hints)}/>

    The hints. Optional.

 * <Member s={Ot.Glyph.horizontal} type={Data.Maybe(Ot.Glyph.Metric)}/>

    The horizontal metric.

 * <Member s={Ot.Glyph.vertical} type={Data.Maybe(Ot.Glyph.Metric)}/>

    The vertical metric.

#### Methods

 * <Method s={Ot.Glyph.apply('E', 'EG', 'EH')} args={{alg:Ot.Glyph.GlyphAlg('E', 'EG', 'EH')}} returns="E"/>

    Accepts a <R s={Ot.Glyph.GlyphAlg} /> and return the results.

### Interface <Decl s={Ot.Glyph.GlyphAlg('E', 'EG = E', 'EH = E')} />

A generic abstract factory or an object algebra about processing glyphs.

#### Properties

* <Member s={Ot.Glyph.GlyphAlg.geometryAlgebra} type={Data.Maybe(Ot.Glyph.GeometryAlg('EG'))} />
* <Member s={Ot.Glyph.GlyphAlg.hintAlgebra} type={Data.Maybe(Ot.Glyph.HintAlg('EH'))} />

#### Methods

 * <Method long s={Ot.Glyph.GlyphAlg.glyph} args={{horizontal:Ot.Glyph.Metric,vertical:Ot.Glyph.Metric,thGeometry:Data.Maybe(Thunk("EG")),thHints:Data.Maybe(Thunk("EH"))}} returns="E" />

## Metrics

### Type <Decl s={Ot.Glyph.Metric}/>

Defines a metric advance of a glyph.

#### Properties

 * <Member readonly s={Ot.Glyph.Metric.start} type={Ot.Var.Value} />

    Start coordiante.

 * <Member readonly s={Ot.Glyph.Metric.end} type={Ot.Var.Value} />

    End coordinate.

## Geometry

### Interface <Decl s={Ot.Glyph.Geometry}/>

#### Methods

 * <Method s={Ot.Glyph.Geometry.apply("E")} args={{alg: Ot.Glyph.GeometryAlg("E")}} returns="E"/>

  Applies an <R s={Ot.Glyph.GeometryAlg("E")}/> algebra to this geometry, and return the results.

### Interface <Decl s={Ot.Glyph.GeometryAlg("E")}/>

A generic abstract factory or an object algebra about processing glyph geometries.

#### Methods

 * <Method s={Ot.Glyph.GeometryAlg.contourSet} args={{csProps: Ot.Glyph.ContourSetProps}} returns="E"/>
 * <Method s={Ot.Glyph.GeometryAlg.ttReference} args={{refProps: Ot.Glyph.TtReferenceProps}} returns="E"/>
 * <Method s={Ot.Glyph.GeometryAlg.geometryList} args={{parts: array("E")}} returns="E"/>

### Type <Decl s={Ot.Glyph.ContourSet}/>

#### Inherits

 * <R s={Ot.Glyph.Geometry} />
 * <R s={Ot.Glyph.ContourSetProps} />

#### Factory Methods

 * <Fn s={Ot.Glyph.ContourSet.create} args={{}} returns={Ot.Glyph.ContourSet}/>

    Creates an <R s={Ot.Glyph.ContourSet}/> with default implementation.

### Interface <Decl s={Ot.Glyph.ContourSetProps}/>

#### Properties

 * <Member s={Ot.Glyph.ContourSetProps.contours} type={array((Ot.Glyph.Contour))} />

    The contour set, being a nested array of control knots.

### Type <Decl s={Ot.Glyph.TtReference}/>

#### Inherits

 * <R s={Ot.Glyph.Geometry} />
 * <R s={Ot.Glyph.TtReferenceProps} />

#### Factory Methods

 * <Fn long s={Ot.Glyph.TtReference.create} args={{
    to: annot(Ot.Glyph,"Target glyph"),
    transform: annot(Ot.Glyph.Transform2X3,"Transform of this reference")
  }} returns={Ot.Glyph.TtReference}/>

    Creates an <R s={Ot.Glyph.TrReference}/> with default implementation.

### Interface <Decl s={Ot.Glyph.TtReferenceProps}/>

#### Properties

 * <Member s={Ot.Glyph.TtReferenceProps.to} type={Ot.Glyph} />

    The target glyph.

 * <Member s={Ot.Glyph.TtReferenceProps.transform} type={Ot.Glyph.Transform2X3} />

    The transform being applied.

 * <Member s={Ot.Glyph.TtReferenceProps.roundXyToGrid} type={boolean} />

    Whether to round to grid.

 * <Member s={Ot.Glyph.TtReferenceProps.useMyMetrics} type={boolean} />

    If set, this forces the advance width and left sidebearing for the composite to be equal to those from this original glyph. This works for hinted and unhinted characters.

 * <Member s={Ot.Glyph.TtReferenceProps.overlapCompound} type={boolean} />

    If set, the components of the glyph containing this reference overlap.

 * <Member s={Ot.Glyph.TtReferenceProps.pointAttachment} type={Data.Maybe(Ot.Glyph.PointAttachment)} />

    When present, this reference follows TrueType's point-attachment rules.

### Type <Decl s={Ot.Glyph.GeometryList}/>

#### Inherits

 * <R s={Ot.Glyph.Geometry} />

#### Factory Methods

 * <Fn s={Ot.Glyph.GeometryList.create} args={{items:optional(array(Ot.Glyph.Geometry))}} returns={Ot.Glyph.GeometryList}/>

    Creates an <R s={Ot.Glyph.GeometryList}/> from its members.

#### Properties

 * <Member s={Ot.Glyph.GeometryList.items} type={array(Ot.Glyph.Geometry)}/>

    The sub geometries inside.

## Hints

### Interface <Decl s={Ot.Glyph.Hint} />

#### Methods

 * <Method s={Ot.Glyph.Hint.apply("E")} args={{alg:Ot.Glyph.HintAlg("E")}} returns="E"/>

    Accepts a <R s={Ot.Glyph.HintAlg("E")} /> algebra to this hint, and return the result.

### Interface <Decl s={Ot.Glyph.HintAlg("E")} />

The object algebra of processing hints.

#### Methods

 * <Method s={Ot.Glyph.HintAlg.ttInstructions} args={{props:Ot.Glyph.TtInstructionProps}} returns="E"/>
 * <Method s={Ot.Glyph.HintAlg.cffHint} args={{props:Ot.Glyph.CffHintProps}} returns="E"/>

### Type <Decl s={Ot.Glyph.TtInstructionHint} />

#### Inherits

 * <R s={Ot.Glyph.Hint} />
 * <R s={Ot.Glyph.TtInstructionProps} />

#### Factory Methods
 * <Fn s={Ot.Glyph.TtInstructionHint.create} args={{instructions:"Buffer"}} returns={Ot.Glyph.TtInstructionHint}/>

    Creates an <R s={Ot.Glyph.TtInstructionHint} /> from a given instruction buffer.

### Interface <Decl s={Ot.Glyph.TtInstructionProps} />

#### Properties

 * <Member s={Ot.Glyph.TtInstructionProps.instructions} type="Buffer"/>

    The buffer containing the TrueType instructions.

### Type <Decl s={Ot.Glyph.CffHint} />

#### Inherits

 * <R s={Ot.Glyph.Hint} />
 * <R s={Ot.Glyph.CffHintProps} />

#### Factory Methods

 * <Fn s={Ot.Glyph.CffHint.create} args={{}} returns={Ot.Glyph.CffHint} />

    Create an empty <R s={Ot.Glyph.CffHint} />.

### Interface <Decl s={Ot.Glyph.CffHintProps} />

#### Properties

 * <Member s={Ot.Glyph.CffHintProps.hStems} type={Ot.Glyph.CffHintStem}/>

    The horizontal stems.

 * <Member s={Ot.Glyph.CffHintProps.vStems} type={Ot.Glyph.CffHintStem}/>

    The vertical stems.

 * <Member s={Ot.Glyph.CffHintProps.hintMasks} type={Ot.Glyph.CffHintMask}/>

    The hint masks.

 * <Member s={Ot.Glyph.CffHintProps.counterMasks} type={Ot.Glyph.CffHintMask}/>

    The contour masks.

### Datatype <Decl s={Ot.Glyph.CffHintStem} />

#### Properties

 * <Member s={Ot.Glyph.CffHintStem.start} type={Ot.Var}/>

    Start coordinate of this hint stem.

 * <Member s={Ot.Glyph.CffHintStem.end} type={Ot.Var}/>

    End coordinate of this hint stem.

#### Factory Methods

 * <Fn s={Ot.Glyph.CffHint.createStem} args={{start:Ot.Var.Value,end:Ot.Var.Value}} returns={Ot.Glyph.CffHintStem} />

    Create a <R s={Ot.Glyph.CffHintStem} />.

### Datatype <Decl s={Ot.Glyph.CffHintMask} />

#### Properties

 * <Member s={Ot.Glyph.CffHintMask.at} type={set(Ot.Glyph.PointRef)}/>

    The point reference right before this hint mask take effect.

 * <Member s={Ot.Glyph.CffHintMask.maskH} type={set(Ot.Glyph.CffHintStem)}/>

    Horizontal stems needed to be enabled.

 * <Member s={Ot.Glyph.CffHintMask.maskH} type={set(Ot.Glyph.CffHintStem)}/>

    Vertical stems needed to be enabled.

#### Factory Methods

 * <Fn long s={Ot.Glyph.CffHint.createMask} args={{
    at:annot(Ot.Glyph.PointRef, "Point reference right before this mask"),
    maskH:annot(set(Ot.Glyph.CffHintStem), "Horizontal stems to be enabled"),
    maskV:annot(set(Ot.Glyph.CffHintStem), "Vertical stems to be enabled")
    }} returns={Ot.Glyph.CffHintMask} />

    Create a <R s={Ot.Glyph.CffHintMask} />.

## Support Types

### Datatype <Decl s={Ot.Glyph.Contour}/>

Defined as <R s={array(Ot.Glyph.Point)} />.

### Datatype <Decl s={Ot.Glyph.Point}/>

<R s={Ot.Glyph.Point}/> defines the datatype of glyph points.

#### Factory Methods

 * <Method long static s={Ot.Glyph.Point.create} args={{
    x: annot(Ot.Var.Value,"X Coordinate"),
    y: annot(Ot.Var.Value,"Y coordinate"),
    kind: optional(annot(Ot.Glyph.PointType,"Point Type"))
  }} returns={Ot.Glyph.Point}/>

#### Properties

 * <Member readonly s={Ot.Glyph.Point.x} type={Ot.Var.Value} />

    X coordinate.

 * <Member readonly s={Ot.Glyph.Point.y} type={Ot.Var.Value} />

    Y coordinate.

 * <Member readonly s={Ot.Glyph.Point.kind} type={Ot.Glyph.PointType} />

    Point type.

### Singleton <Decl s={Ot.Glyph.PointOps}/>

#### Properties

 * <Member readonly s={Ot.Glyph.PointOps.neutral} type={number} />

    The identity of <R s={Ot.Glyph.Point}/>. Equal to 0.

#### Methods
 * <Method s={Ot.Glyph.PointOps.add} args={{x:Ot.Glyph.Point,y:Ot.Glyph.Point}} returns={Ot.Glyph.Point} />
 * <Method s={Ot.Glyph.PointOps.negate} args={{x:Ot.Glyph.Point}} returns={Ot.Glyph.Point} />
 * <Method s={Ot.Glyph.PointOps.minus} args={{x:Ot.Glyph.Point,y:Ot.Glyph.Point}} returns={Ot.Glyph.Point} />
 * <Method s={Ot.Glyph.PointOps.scale} args={{scale:number,y:Ot.Glyph.Point}} returns={Ot.Glyph.Point} />
 * <Method s={Ot.Glyph.PointOps.addScale} args={{x:Ot.Glyph.Point,scale:number,y:Ot.Glyph.Point}} returns={Ot.Glyph.Point} />
 * <Method s={Ot.Glyph.PointOps.applyTransform} args={{x:Ot.Glyph.Point,transform:Ot.Glyph.Transform2X3}} returns={Ot.Glyph.Point} />

### Type <Decl s={Ot.Glyph.Transform2X3}/>

#### Properties

 * <Member readonly s={Ot.Glyph.Transform2X3.dx} type={Ot.Var.Value} />
 * <Member readonly s={Ot.Glyph.Transform2X3.dy} type={Ot.Var.Value} />
 * <Member readonly s={Ot.Glyph.Transform2X3.xx} type={number} />
 * <Member readonly s={Ot.Glyph.Transform2X3.xy} type={number} />
 * <Member readonly s={Ot.Glyph.Transform2X3.yx} type={number} />
 * <Member readonly s={Ot.Glyph.Transform2X3.yy} type={number} />

    2×3 transformation entries.

 * <Member readonly s={Ot.Glyph.Transform2X3.scaledOffset} type={Data.Maybe(boolean)} />

    Whether the offset is scaled.

### Enumeration <Decl s={Ot.Glyph.PointType}/>

 * <Item s={Ot.Glyph.PointType.Corner} /> = 0

    This point is corner point.

 * <Item s={Ot.Glyph.PointType.Lead} /> = 1

    This point is the first control point of a cubic Beizer curve.

 * <Item s={Ot.Glyph.PointType.Follow} /> = 2

    This point is the second control point of a cubic Beizer curve.

 * <Item s={Ot.Glyph.PointType.Quad} /> = 3

    This point is an off-curve control point in a quadratic contour, as in TrueType.

### Datatype <Decl s={Ot.Glyph.PointRef} />

#### Properties

 * <Member readonly s={Ot.Glyph.PointRef.geometry} type={number} />
 * <Member readonly s={Ot.Glyph.PointRef.contour} type={number} />
 * <Member readonly s={Ot.Glyph.PointRef.index} type={number} />

### Datatype <Decl s={Ot.Glyph.PointIDRef} />

#### Properties

 * <Member readonly s={Ot.Glyph.PointIDRef.pointIndex} type={number} />

### Datatype <Decl s={Ot.Glyph.GlyphPointIDRef} />

#### Properties

 * <Member readonly s={Ot.Glyph.GlyphPointIDRef.glyph} type={Ot.Glyph} />
 * <Member readonly s={Ot.Glyph.GlyphPointIDRef.pointIndex} type={number} />

### Datatype <Decl s={Ot.Glyph.PointAttachment} />

#### Properties

 * <Member readonly s={Ot.Glyph.PointAttachment.inner} type={Ot.Glyph.PointIDRef} />
 * <Member readonly s={Ot.Glyph.PointAttachment.outer} type={Ot.Glyph.PointIDRef} />

## Glyph Naming

### Type <Decl s={Ot.GlyphNamingSource}/>

#### Properties

* <Member readonly s={Ot.GlyphNamingSource.post} type={Data.Maybe(Data.Naming.Source(Ot.Glyph))}/>
* <Member readonly s={Ot.GlyphNamingSource.cff} type={Data.Maybe(Data.Naming.Source(Ot.Glyph))}/>
* <Member readonly s={Ot.GlyphNamingSource.encoding} type={Data.Maybe(Data.Naming.IndexSource(Ot.Glyph))}/>

### Interface <Decl s={Ot.GlyphNamer}/>

#### Properties

* <Method s={Ot.GlyphNamer.nameGlyph} args={{source:Ot.GlyphNamingSource,gid:number, glyph:Ot.Glyph}} returns={string}/>

### Singleton <Decl s={Ot.StandardOtGlyphNamer}/>

The default glyph namer, implements <R s={Ot.GlyphNamer}/>.